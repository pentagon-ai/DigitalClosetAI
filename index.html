<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Closet AI</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* カスタムアニメーション設定 */
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fade-in 0.2s ease-out; }
        @keyframes slide-up { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .animate-slide-up { animation: slide-up 0.4s ease-out; }
        @keyframes bounce-in { 0% { transform: translate(-50%, -20px); opacity: 0; } 60% { transform: translate(-50%, 5px); opacity: 1; } 100% { transform: translate(-50%, 0); } }
        .animate-bounce-in { animation: bounce-in 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes wiggle { 0% { transform: rotate(0deg); } 25% { transform: rotate(-1.5deg); } 50% { transform: rotate(0deg); } 75% { transform: rotate(1.5deg); } 100% { transform: rotate(0deg); } } 
        .animate-wiggle { animation: wiggle 0.3s ease-in-out infinite; }
        .select-none { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        
        @keyframes blob {
            0% { transform: translate(0px, 0px) scale(1); }
            33% { transform: translate(10px, -10px) scale(1.1); }
            66% { transform: translate(-10px, 10px) scale(0.9); }
            100% { transform: translate(0px, 0px) scale(1); }
        }
        .animate-blob { animation: blob 5s infinite; }
        .animation-delay-2000 { animation-delay: 2s; }
        .animation-delay-4000 { animation-delay: 4s; }
    </style>
</head>
<body class="bg-gray-100 h-screen w-full overflow-hidden">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
        import React, { useState, useRef, useEffect, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
          Camera, X, Shirt, Cloud, Pause, Circle, Gem, Home, PlusCircle, Trash2, Check, 
          Sparkles, MessageCircle, Wand2, User, Loader, AlertTriangle, Layers, ShoppingBag, 
          Heart, ChevronRight, Lightbulb, ImagePlus, Lock, Unlock, Edit3, RefreshCw, 
          Filter, LayoutGrid, Star, Box, Tag, ListFilter, Info 
        } from 'lucide-react';

        // --- Types ---
        type Category = 'outer' | 'tops' | 'bottoms' | 'shoes' | 'bag' | 'accessories';
        type StyleType = 'clean' | 'casual';
        type ViewType = 'home' | 'camera' | 'closet' | 'fitting' | 'coordinate' | 'model';

        interface StyleAnalysis {
            material: string;
            materialScore: number; // 0-100
            color: string;
            colorScore: number; // 0-100
            shape: string;
            shapeScore: number; // 0-100
        }

        interface WardrobeItem {
            id: string;
            image: string; // Base64 data
            category: Category;
            date: number;
            isPinned?: boolean;
            styleType?: StyleType; 
            styleScore?: number; // 0 (Casual) to 100 (Dress)
            styleAnalysis?: StyleAnalysis;
        }

        interface AiAdvice {
            rating: number; 
            comment: string;
            scenario: string;
            cleanPercent?: number; 
            casualPercent?: number; 
        }

        interface FavoriteOutfit {
            id: string;
            items: WardrobeItem[];
            generatedImage: string | null;
            advice: AiAdvice | null;
            season?: string;
            scene?: string;
            date: number;
        }

        // --- Utils ---
        const generateId = () => Math.random().toString(36).substr(2, 9);

        // UI用（保存用）
        const compressImage = (base64Str, maxWidth = 800, quality = 0.8) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = base64Str;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    if (width > maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.fillStyle = "#FFFFFF";
                        ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    } else {
                        resolve(base64Str);
                    }
                };
                img.onerror = () => resolve(base64Str);
            });
        };

        // API送信専用
        const compressForApi = async (base64Str) => {
            return compressImage(base64Str, 400, 0.6);
        };

        const CATEGORIES = [
          { id: 'outer', label: 'アウター', icon: Cloud }, 
          { id: 'tops', label: 'トップス', icon: Shirt },
          { id: 'bottoms', label: 'ボトムス', icon: Pause },
          { id: 'shoes', label: 'シューズ', icon:  Circle },
          { id: 'bag', label: 'バッグ', icon: ShoppingBag },
          { id: 'accessories', label: 'アクセサリー', icon: Gem },
        ];

        const SEASONS = ['春', '夏', '秋', '冬'];

        // Updated Scenes
        const SCENES_FORMAL = ['オフィス', 'パーティー（二次会）', 'デート（きれいめ）'];
        const SCENES_CASUAL = ['デート（カジュアル）', 'リラックス・休日', 'アウトドア'];
        const SCENES = [...SCENES_FORMAL, ...SCENES_CASUAL];

        const SCENE_STYLE_MAP = {
          'オフィス': 'Business Formal / Clean style. Professional look. Bag must be a business bag, tote, or simple leather bag. NO backpacks, NO casual sporty bags.',
          'パーティー（二次会）': 'Formal / Wedding After-Party style. Elegant, dressy. Bag must be a clutch, small leather bag, or formal handbag. NO backpacks, NO large totes, NO casual bags.',
          'デート（きれいめ）': 'Smart Casual / Clean style. Stylish and attractive. Bag should be a nice handbag, leather tote, or clean shoulder bag.',
          'デート（カジュアル）': 'Casual / Trendy style. Fashionable but comfortable. Casual bags like totes or stylish backpacks are okay.',
          'リラックス・休日': 'Relaxed / Casual style. Comfort first. Canvas totes, casual backpacks, or sacoches are suitable.',
          'アウトドア': 'Active / Casual style. Functional and durable. Backpacks, body bags, or sporty bags are best. NO leather business bags, NO formal clutches.'
        };

        const SCENE_BACKGROUNDS = {
          'オフィス': 'modern bright office interior background, professional atmosphere',
          'デート（カジュアル）': 'fashionable city street background, urban shopping district, daytime',
          'デート（きれいめ）': 'elegant restaurant or stylish cafe interior background, romantic atmosphere',
          'アウトドア': 'nature park background with green trees and blue sky, outdoor natural setting',
          'リラックス・休日': 'cozy living room interior background with sofa, relaxing home atmosphere',
          'パーティー（二次会）': 'luxury party venue background, wedding after-party atmosphere, warm lighting, evening'
        };

        const SEASON_ATMOSPHERES = {
          '春': 'spring season, soft warm sunlight, cherry blossoms in distance',
          '夏': 'summer season, bright strong sunlight, clear blue sky, vibrant colors',
          '秋': 'autumn season, warm golden lighting, falling leaves background',
          '冬': 'winter season, cold crisp lighting, maybe snow in background'
        };

        // --- Gemini API Helper ---
        // ★★★重要：ここにAPIキーが入っています★★★
        const apiKey = "AIzaSyBtvk6L0N6M4s33WkyUFbiOnZXcpfYaEmo"; 

        const parseGeminiJson = (text) => {
            if (!text) return null;
            try {
                const match = text.match(/\{[\s\S]*\}/);
                if (match) return JSON.parse(match[0]);
                return JSON.parse(text);
            } catch (e) {
                try {
                    const cleaned = text.replace(/```json/g, '').replace(/```/g, '').trim();
                    return JSON.parse(cleaned);
                } catch (e2) {
                    return null;
                }
            }
        };

        const callGeminiText = async (prompt, images) => {
          if (!apiKey) { alert("APIキーが設定されていません"); return null; }
          try {
            const parts = [{ text: prompt }];
            if (images && images.length > 0) {
                for (const img of images) {
                    if (img && typeof img === 'string' && img.includes(',')) {
                        const resized = await compressForApi(img);
                        parts.push({ inlineData: { mimeType: "image/jpeg", data: resized.split(',')[1] } });
                    }
                }
            }

            const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts }], generationConfig: { responseMimeType: "application/json" } })
              }
            );

            if (!response.ok) return null;
            const data = await response.json();
            const rawText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!rawText) return null;
            return parseGeminiJson(rawText);
          } catch (error) {
            console.error("Gemini Text API Error:", error);
            return null;
          }
        };

        const callGeminiImageGen = async (prompt, images) => {
          if (!apiKey) { alert("APIキーが設定されていません"); return null; }
          try {
            const parts = [{ text: prompt }];
            if (images && images.length > 0) {
                for (const img of images) {
                    if (img && typeof img === 'string' && img.includes(',')) {
                        const resized = await compressForApi(img);
                        parts.push({ inlineData: { mimeType: "image/jpeg", data: resized.split(',')[1] } });
                    }
                }
            }
            
            // Note: Using a standard model for compatibility in this demo context
            const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                // Requesting standard text response but prompting for image description or using available model capabilities
                // Since actual image generation model endpoint might differ, we stick to text-based or standard multimodal
                body: JSON.stringify({ contents: [{ parts }], generationConfig: { responseModalities: ["image"] } })
              }
            );

            if (!response.ok) return null;
            const data = await response.json();
            const generatedImagePart = data.candidates?.[0]?.content?.parts?.find((p) => p.inlineData);
            if (generatedImagePart) {
                return `data:image/jpeg;base64,${generatedImagePart.inlineData.data}`;
            }
            return null;
          } catch (error) {
            console.error("Gemini Image API Error:", error);
            return null;
          }
        };

        // --- Custom Components ---

        const MagicLoader = ({ size = 64, text = "AI Processing..." }) => {
            return (
                <div className="flex flex-col items-center justify-center p-4">
                    <svg style={{ position: 'absolute', width: 0, height: 0 }}>
                        <defs>
                            <filter id="goo-effect">
                                <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
                                <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" result="goo" />
                                <feBlend in="SourceGraphic" in2="goo" />
                            </filter>
                        </defs>
                    </svg>

                    <div className="relative flex items-center justify-center" style={{ width: size + 20, height: size + 20, filter: 'url(#goo-effect)' }}>
                        <div className="absolute rounded-full bg-gradient-to-r from-pink-500 to-orange-400 animate-blob mix-blend-multiply filter blur-xl opacity-70"
                             style={{ width: size, height: size, top: 0, left: -10 }}></div>
                        <div className="absolute rounded-full bg-gradient-to-r from-orange-400 to-yellow-400 animate-blob animation-delay-2000 mix-blend-multiply filter blur-xl opacity-70"
                             style={{ width: size, height: size, top: 0, right: -10 }}></div>
                        <div className="absolute rounded-full bg-gradient-to-r from-pink-400 to-red-400 animate-blob animation-delay-4000 mix-blend-multiply filter blur-xl opacity-70"
                             style={{ width: size, height: size, bottom: -10, left: 10 }}></div>
                    </div>
                    
                    <div className="absolute flex items-center justify-center">
                         <Sparkles size={size * 0.4} className="text-white animate-pulse drop-shadow-[0_0_10px_rgba(255,255,255,0.8)]" fill="currentColor" />
                    </div>

                    {text && (
                        <p className="mt-4 text-sm font-bold bg-clip-text text-transparent bg-gradient-to-r from-pink-600 to-orange-500 animate-pulse z-10 text-center">
                            {text}
                        </p>
                    )}
                </div>
            );
        };

        const StarRating = ({ rating }) => (
            <div className="flex gap-1">
                {[1, 2, 3, 4, 5].map((star) => (
                    <Sparkles key={star} size={16} className={`${star <= rating ? 'text-yellow-400 fill-yellow-400' : 'text-gray-200'}`} />
                ))}
            </div>
        );

        const StyleBar = ({ score, label, small = false }) => {
            return (
                <div className="w-full">
                    {label && (
                        <div className="flex justify-between text-[10px] font-bold mb-1">
                            <span className="text-gray-500">{label}</span>
                        </div>
                    )}
                    {!label && !small && (
                        <div className="flex justify-between text-[10px] font-bold mb-1">
                            <span className="text-orange-500">CASUAL</span>
                            <span className="text-gray-900">DRESS</span>
                        </div>
                    )}
                    <div className={`relative w-full ${small ? 'h-2' : 'h-3'} bg-gray-100 rounded-full overflow-hidden border border-gray-200`}>
                        <div className="absolute inset-0 bg-gradient-to-r from-orange-400 via-gray-300 to-gray-800 opacity-80"></div>
                        <div 
                            className={`absolute top-1/2 -translate-y-1/2 ${small ? 'w-3 h-3' : 'w-4 h-4'} bg-white border-2 border-gray-600 rounded-full shadow-md z-10`}
                            style={{ left: `calc(${score}% - ${small ? '6px' : '8px'})` }}
                        ></div>
                    </div>
                </div>
            );
        };

        const FavoriteDetailOverlay = ({ favorite, onClose, onDelete }) => {
            let comment = "No comment available";
            if (favorite.advice?.comment) {
                if (typeof favorite.advice.comment === 'string') {
                    comment = favorite.advice.comment;
                } else {
                    comment = JSON.stringify(favorite.advice.comment);
                }
            }
            
            const dressScore = favorite.advice?.cleanPercent ?? 50;
            const casualScore = 100 - dressScore;

            return (
                <div className="absolute inset-0 z-[60] bg-white flex flex-col animate-fade-in" onClick={(e) => e.stopPropagation()}>
                    <div className="px-6 pt-6 pb-2 flex justify-between items-center bg-white shrink-0">
                        <h2 className="text-xl font-bold text-gray-800">Coordinate Details</h2>
                        <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X size={24} /></button>
                    </div>
                    <div className="flex-1 overflow-y-auto p-6 space-y-6 pb-24">
                        <div className="relative w-full aspect-[3/4] bg-gray-100 rounded-2xl overflow-hidden shadow-md">
                            {favorite.generatedImage ? (
                                <img src={favorite.generatedImage} className="w-full h-full object-cover" alt="Detail" />
                            ) : (
                                <div className="w-full h-full flex flex-col items-center justify-center text-gray-400">
                                    <Sparkles size={48} className="mb-2" />
                                    <span>画像なし</span>
                                </div>
                            )}
                        </div>
                        
                        <div className="bg-white p-4 rounded-xl border border-gray-100 shadow-sm">
                            <h4 className="font-bold text-gray-700 mb-2 text-xs flex items-center gap-1">
                                <Filter size={14} className="text-purple-500" /> コーデ分析
                            </h4>
                            <StyleBar score={dressScore} />
                            <div className="flex justify-between text-[10px] font-bold mt-1">
                                <span className="text-orange-500">{casualScore}%</span>
                                <span className="text-gray-900">{dressScore}%</span>
                            </div>
                        </div>

                        <div className="space-y-4">
                            <div className="flex items-center justify-between">
                                <div className="flex gap-2">
                                        <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-bold">{favorite.season}</span>
                                        <span className="bg-purple-100 text-purple-800 px-3 py-1 rounded-full text-sm font-bold">{favorite.scene}</span>
                                </div>
                                {favorite.advice?.rating && <StarRating rating={favorite.advice.rating} />}
                            </div>
                            <div className="bg-gray-50 p-4 rounded-xl border border-gray-100">
                                <h4 className="font-bold text-gray-700 mb-2 flex items-center gap-2"><MessageCircle size={18} className="text-purple-600" />スタイリストコメント</h4>
                                <p className="text-sm text-gray-700 leading-relaxed whitespace-pre-wrap">{comment}</p>
                            </div>
                            <div>
                                <h4 className="font-bold text-gray-700 mb-2">使用アイテム</h4>
                                <div className="grid grid-cols-4 gap-2">
                                    {favorite.items.map((item, i) => (
                                        <div key={i} className="aspect-square rounded-lg overflow-hidden border border-gray-200">
                                            <img src={item.image} className="w-full h-full object-cover" alt="item" />
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div className="pt-4">
                                <button onClick={() => { if(window.confirm("このお気に入りを削除しますか？")) { onDelete(favorite.id); }}}
                                    className="w-full py-3 border border-red-200 text-red-500 rounded-xl font-bold hover:bg-red-50 flex items-center justify-center gap-2">
                                    <Trash2 size={20} /> 削除する
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // 1. Home View
        const HomeView = ({ items, setView, userModel, setUserModel, showNotification }) => {
            const [diagnosis, setDiagnosis] = useState(null);
            const [recommendedImages, setRecommendedImages] = useState([]);
            const [isDiagnosing, setIsDiagnosing] = useState(false);
            const fileInputRef = useRef(null);

            const handleUpload = (e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        const compressed = await compressImage(ev.target?.result, 800, 0.8);
                        setUserModel(compressed);
                        showNotification("マイモデルを登録しました");
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleDiagnosis = async () => {
                if (items.length === 0) { alert("まずはアイテムを登録してください！"); return; }
                setIsDiagnosing(true);
                setDiagnosis(null);
                setRecommendedImages([]);
                try {
                    const counts = CATEGORIES.map(cat => {
                        const count = items.filter(i => i.category === cat.id).length;
                        return `${cat.label}: ${count}着`;
                    }).join(', ');
                    
                    const itemImages = [];
                    CATEGORIES.forEach(cat => {
                        const catItems = items.filter(i => i.category === cat.id).sort((a, b) => b.date - a.date).slice(0, 4);
                        catItems.forEach(i => itemImages.push(i.image));
                    });

                    const prompt = `
                    Fashion consultant advice. Inventory: ${counts}.
                    First, guess the user's gender (Men's or Ladies') based on the inventory items.
                    Then provide a detailed fashion advice (about 4-6 sentences, specific and helpful) and up to 3 recommended items suitable for that gender.
                    
                    Rules for Advice:
                    - Identify Missing Staples: If standard staple items are missing, STRONGLY recommend them. 
                    - Avoid Duplicates.
                    - Balance Styles (Dress vs Casual).
                    - Provide concrete styling tips.
                    
                    Return JSON: { "message": "Detailed advice in Japanese...", "recommendedItems": ["Item Name 1", "Item Name 2", "Item Name 3"] }
                    `;
                    
                    const result = await callGeminiText(prompt, itemImages);
                    if (result && result.message) {
                        setDiagnosis(result);
                        if (result.recommendedItems && Array.isArray(result.recommendedItems)) {
                            const promises = result.recommendedItems.slice(0, 3).map(itemName => 
                                callGeminiImageGen(`Product photo of ${itemName}, white background, high quality.`, [])
                            );
                            const images = await Promise.all(promises);
                            setRecommendedImages(images.filter(img => img !== null));
                        }
                    } else {
                        alert("診断データの取得に失敗しました。");
                    }
                } catch (e) {
                    alert("エラーが発生しました。");
                } finally {
                    setIsDiagnosing(false);
                }
            };
            
            let message = "";
            if (diagnosis?.message) {
                message = typeof diagnosis.message === 'string' ? diagnosis.message : JSON.stringify(diagnosis.message);
            }

            return (
              <div className="flex flex-col items-center justify-start h-full p-6 text-center space-y-6 animate-fade-in overflow-y-auto pb-24">
                <div className="relative mt-6 mb-2">
                    <div className="absolute inset-0 bg-gradient-to-r from-purple-400 via-pink-500 to-orange-400 blur-2xl opacity-30 rounded-full scale-125"></div>
                    <div className="relative bg-white/80 backdrop-blur-md p-5 rounded-3xl border border-white/60 shadow-xl ring-1 ring-purple-50">
                        <Gem size={40} className="text-transparent bg-clip-text bg-gradient-to-br from-purple-600 to-pink-500 fill-purple-50" strokeWidth={1.2} />
                        <Sparkles className="absolute -top-3 -right-3 text-yellow-400 drop-shadow-sm" size={24} fill="#FFD700" strokeWidth={0} />
                    </div>
                </div>
                <div>
                  <h1 className="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-gray-800 to-gray-600 mb-1 tracking-tight">Digital Closet AI</h1>
                  <p className="text-xs text-gray-500 font-medium tracking-wide">あなたのクローゼットをデジタル管理</p>
                </div>
                <div className="w-full bg-white rounded-2xl shadow-sm border border-gray-100 p-4">
                    <div className="flex justify-between items-center mb-4 pb-2 border-b border-gray-100">
                        <h3 className="font-bold text-gray-700">登録アイテム数</h3>
                        <span className="text-2xl font-bold text-purple-600">{items.length}</span>
                    </div>
                    <div className="grid grid-cols-3 gap-3">
                        {CATEGORIES.map(cat => (
                            <div key={cat.id} className="flex flex-col items-center p-2 bg-gray-50 rounded-xl">
                                <cat.icon size={16} className="text-gray-400 mb-1" />
                                <span className="text-[10px] text-gray-500">{cat.label}</span>
                                <span className="text-sm font-bold text-gray-800">{items.filter(i => i.category === cat.id).length}</span>
                            </div>
                        ))}
                    </div>
                </div>
                <div className="w-full">
                    {!diagnosis ? (
                        <button onClick={handleDiagnosis} disabled={isDiagnosing} className="w-full py-3 bg-gradient-to-r from-pink-500 to-orange-500 text-white rounded-xl font-bold shadow-md hover:opacity-90 flex items-center justify-center gap-2 text-sm transition-all active:scale-95">
                            {isDiagnosing ? <MagicLoader size={20} text="" /> : <Lightbulb size={18} />}
                            {isDiagnosing ? "AI診断中..." : "クローゼット診断を受ける"}
                        </button>
                    ) : (
                        <div className="bg-purple-50 p-4 rounded-xl text-left border border-purple-100 animate-slide-up">
                            <h3 className="font-bold text-purple-700 mb-2 flex items-center gap-2 text-sm"><Sparkles size={16} /> AIからのアドバイス</h3>
                            <p className="text-sm text-gray-700 leading-relaxed whitespace-pre-wrap">{message}</p>
                            
                            {diagnosis.recommendedItems && diagnosis.recommendedItems.length > 0 && (
                                <div className="mt-4 space-y-3">
                                     <p className="text-xs font-bold text-purple-600 mb-2 flex items-center gap-1"><ShoppingBag size={12} /> おすすめアイテム:</p>
                                     <div className="grid grid-cols-3 gap-2">
                                        {diagnosis.recommendedItems.slice(0, 3).map((item, idx) => {
                                            const itemName = typeof item === 'string' ? item : 'Item';
                                            return (
                                                <div key={idx} className="bg-white p-2 rounded-lg border border-purple-100 flex flex-col items-center">
                                                    <div className="relative w-full aspect-square bg-gray-100 rounded-md overflow-hidden flex items-center justify-center mb-1">
                                                        {recommendedImages[idx] ? <img src={recommendedImages[idx]} alt="Rec" className="w-full h-full object-contain" /> : <MagicLoader size={16} text="" />}
                                                    </div>
                                                    <span className="text-[10px] text-center text-gray-600 leading-tight line-clamp-2">{itemName}</span>
                                                </div>
                                            );
                                        })}
                                     </div>
                                </div>
                            )}

                            <button onClick={() => { setDiagnosis(null); setRecommendedImages([]); }} className="text-xs text-gray-400 mt-4 underline w-full text-center">閉じる</button>
                        </div>
                    )}
                </div>
                <div className="w-full pt-6 pb-2 border-t border-gray-100">
                    <h3 className="text-sm font-bold text-gray-700 mb-3 flex items-center justify-center gap-2"><User size={16} /> マイモデル設定</h3>
                    <div className="flex flex-col items-center gap-3">
                        <div onClick={() => fileInputRef.current?.click()} className="relative w-20 h-20 bg-gray-100 rounded-full overflow-hidden border-2 border-dashed border-gray-300 flex items-center justify-center shadow-sm cursor-pointer hover:bg-gray-50 transition active:scale-95">
                            {userModel ? <img src={userModel} alt="My Model" className="w-full h-full object-cover" /> : <User size={24} className="text-gray-300" />}
                            <div className="absolute inset-0 bg-black/0 hover:bg-black/10 transition flex items-center justify-center">
                                <PlusCircle size={20} className="text-white opacity-0 hover:opacity-100" />
                            </div>
                        </div>
                        <p className="text-[10px] text-gray-400 text-center leading-tight">あなたの写真を登録すると<br/>AI が 似た人物で試着イメージを生成します。</p>
                        {userModel && <button onClick={() => { setUserModel(null); showNotification("写真を削除しました"); }} className="text-xs text-red-400 hover:text-red-600 underline">写真を削除</button>}
                        <input type="file" ref={fileInputRef} onChange={handleUpload} accept="image/*" className="hidden" />
                    </div>
                </div>

                {isDiagnosing && (
                    <div className="absolute inset-0 z-50 bg-white/80 flex flex-col items-center justify-center animate-fade-in backdrop-blur-sm">
                        <MagicLoader size={120} text="AIがクローゼット診断中..." />
                    </div>
                )}
              </div>
            );
        };

        // 2. Camera/Editor View
        const CameraEditorView = ({ addItem, setView, showNotification, editorState, setEditorState, setLastSelectedCategory }) => {
            const [isProcessingImage, setIsProcessingImage] = useState(false);
            const [isSaved, setIsSaved] = useState(false);
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);

            useEffect(() => { setIsSaved(false); }, [editorState.imageSrc]);

            const handleFileChange = (e) => {
              const file = e.target.files?.[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                  setEditorState({ ...editorState, imageSrc: ev.target?.result });
                };
                reader.readAsDataURL(file);
                e.target.value = ''; 
              }
            };

            const drawToCanvas = useCallback((callback) => {
                 if (!canvasRef.current || !editorState.imageSrc) return;
                 const canvas = canvasRef.current;
                 const ctx = canvas.getContext('2d');
                 const img = new Image();
                 img.src = editorState.imageSrc;
                 img.onload = () => {
                    const targetW = 600;
                    const targetH = 800; 
                    canvas.width = targetW;
                    canvas.height = targetH;
                    if (ctx) {
                        ctx.fillStyle = "#FFFFFF";
                        ctx.fillRect(0, 0, targetW, targetH);
                        const scale = Math.min(targetW / img.width, targetH / img.height);
                        const x = (targetW / 2) - (img.width / 2) * scale;
                        const y = (targetH / 2) - (img.height / 2) * scale;
                        ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                        const data = canvas.toDataURL('image/jpeg', 0.8);
                        if (callback) callback(data);
                    }
                 };
            }, [editorState.imageSrc]);

            useEffect(() => {
                if (editorState.imageSrc) drawToCanvas();
            }, [editorState.imageSrc, drawToCanvas]);

            const handleAiImageProcess = async () => {
                setIsProcessingImage(true);
                drawToCanvas(async (processedImage) => {
                    const stylePrompt = `
                        Analyze this fashion item image.
                        Provide a score from 0 (Casual) to 100 (Dress).
                        
                        Evaluation criteria:
                        1. Material: Rough/Matte/Denim/Jersey -> Lower Score. Smooth/Glossy/Wool/Silk/Leather -> Higher Score.
                        2. Color/Pattern: Vivid/Neon/Large patterns -> Lower Score. Monotone/Black/White/Navy/Brown/Simple -> Higher Score.
                        3. Shape: T-shirt/Hoodie/Shorts/Sneakers -> Lower Score. Collared Shirt/Jacket/Slacks/Leather Shoes -> Higher Score.
                        
                        Analyze these 3 factors SEPARATELY.
                        Return JSON: { 
                            "score": number (0-100), 
                            "materialScore": number (0-100),
                            "colorScore": number (0-100),
                            "shapeScore": number (0-100),
                            "material": "Brief description of material in Japanese", 
                            "color": "Brief description of color in Japanese", 
                            "shape": "Brief description of shape in Japanese" 
                        }
                    `;
                    const styleResult = await callGeminiText(stylePrompt, [processedImage]);
                    const styleScore = styleResult?.score !== undefined ? styleResult.score : 50;
                    const styleType = styleScore >= 50 ? 'clean' : 'casual';
                    
                    const analysis = {
                        material: styleResult?.material || '不明',
                        materialScore: styleResult?.materialScore ?? 50,
                        color: styleResult?.color || '不明',
                        colorScore: styleResult?.colorScore ?? 50,
                        shape: styleResult?.shape || '不明',
                        shapeScore: styleResult?.shapeScore ?? 50
                    };

                    const categoryLabel = CATEGORIES.find(c => c.id === editorState.category)?.label || 'clothing item';
                    const prompt = `Crop and isolate the ${categoryLabel} from this image on a pure white background. Do not fold the item. Show the entire item flat and straight. High quality product photo.`;
                    const generatedImage = await callGeminiImageGen(prompt, [processedImage]);
                    setIsProcessingImage(false);
                    if (generatedImage) {
                        setEditorState({ ...editorState, imageSrc: generatedImage, styleType: styleType, styleScore: styleScore, styleAnalysis: analysis }); 
                        showNotification(`AIが${categoryLabel}を切り出し、スタイルを判定しました！`);
                    } else {
                        showNotification("画像生成に失敗しました");
                    }
                });
            };

            const handleSave = () => {
              drawToCanvas((processedImage) => {
                  addItem({
                    id: generateId(),
                    image: processedImage,
                    category: editorState.category,
                    date: Date.now(),
                    styleType: editorState.styleType || 'casual',
                    styleScore: editorState.styleScore,
                    styleAnalysis: editorState.styleAnalysis
                  });
                  setLastSelectedCategory(editorState.category);
                  
                  setIsSaved(true);
                  showNotification(`${CATEGORIES.find(c => c.id === editorState.category)?.label}を保存しました`);
              });
            };

            return (
              <div className="flex flex-col h-full bg-gray-50 animate-slide-up overflow-y-auto">
                <div className="bg-gray-200 w-full py-2 flex items-center justify-center shrink-0">
                    <div className="relative w-full max-w-sm aspect-[3/4] bg-white shadow-lg overflow-hidden flex items-center justify-center">
                        {isProcessingImage ? <MagicLoader size={48} text="AI 加工中..." /> : (
                            editorState.imageSrc ? <img src={editorState.imageSrc} alt="Preview" className="w-full h-full object-contain bg-white" /> :
                            <div className="flex flex-col items-center justify-center h-full text-gray-400">
                                 <Camera size={48} className="mb-2 opacity-20" />
                                 <p className="text-sm">写真を選択してください</p>
                            </div>
                        )}
                        <button onClick={() => fileInputRef.current?.click()} className="absolute top-4 left-4 bg-black/50 text-white p-2 rounded-full hover:bg-black/70 transition flex items-center gap-1" disabled={isProcessingImage}><ImagePlus size={20} /></button>
                    </div>
                    <canvas ref={canvasRef} className="hidden" />
                </div>

                <div className="flex-1 p-6 space-y-4 pb-24">
                    <p className="text-xs text-center text-gray-500">カテゴリーを選んで「AI加工」を押すと、<br/>写真からそのアイテムを切り出します。</p>
                    <div>
                        <h3 className="text-sm font-bold text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2"><Layers size={16} /> カテゴリーを選択</h3>
                        <div className="grid grid-cols-3 gap-2">
                        {CATEGORIES.map(cat => (
                            <button key={cat.id} onClick={() => setEditorState({ ...editorState, category: cat.id })} disabled={isProcessingImage}
                                className={`p-3 rounded-xl text-xs font-bold transition flex flex-col items-center gap-2 justify-center aspect-[4/3] ${editorState.category === cat.id ? 'bg-purple-600 text-white shadow-md ring-2 ring-purple-200' : 'bg-white text-gray-600 border border-gray-200 hover:bg-gray-50'}`}>
                                <cat.icon size={20} /><span>{cat.label}</span>
                            </button>
                        ))}
                        </div>
                    </div>
                    <div>
                        <h3 className="text-sm font-bold text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2"><Wand2 size={16} /> 画像を整える</h3>
                        <button onClick={handleAiImageProcess} disabled={isProcessingImage || !editorState.imageSrc} className="w-full bg-gradient-to-r from-pink-500 to-orange-500 text-white py-3 rounded-xl font-bold shadow-md hover:opacity-90 disabled:opacity-50 flex items-center justify-center gap-2">
                            {isProcessingImage ? <Loader size={16} className="animate-spin" /> : <><Wand2 size={18} /> AI加工（切り出し）</>}
                        </button>
                    </div>
                    
                    {editorState.styleScore !== undefined && (
                        <div className="mt-2 bg-white p-3 rounded-xl border border-purple-100 shadow-sm animate-fade-in">
                             <h4 className="text-xs font-bold text-gray-700 mb-2 flex items-center gap-1"><Tag size={12}/> AI判定結果</h4>
                             <StyleBar score={editorState.styleScore} />
                             
                             {editorState.styleAnalysis && (
                                 <div className="mt-2 space-y-1">
                                     <StyleBar score={editorState.styleAnalysis.materialScore} label="素材" small />
                                     <StyleBar score={editorState.styleAnalysis.colorScore} label="色" small />
                                     <StyleBar score={editorState.styleAnalysis.shapeScore} label="形" small />
                                 </div>
                             )}
                        </div>
                    )}

                    <div className="mt-2">
                        <button onClick={handleSave} disabled={isProcessingImage || isSaved || !editorState.imageSrc} className={`w-full py-4 rounded-xl font-bold shadow-lg transition flex items-center justify-center gap-2 ${isSaved ? 'bg-gray-300 text-white cursor-not-allowed' : 'bg-gray-900 text-white hover:bg-gray-800'}`}>
                            {isSaved ? <><Check size={20} /> 保存済み</> : <><Check size={20} /> 保存</>}
                        </button>
                    </div>
                </div>
              </div>
            );
        };

        // 3. Closet View
        const ClosetView = ({ items, requestDelete, updateItem, favorites, onSelectFavorite, reorderItems, togglePin }) => {
          const [activeTab, setActiveTab] = useState('all');
          const [editingItem, setEditingItem] = useState(null);
          const [isWiggleMode, setIsWiggleMode] = useState(false);
          const longPressTimerRef = useRef(null);
          const filteredItems = activeTab === 'all' ? items : items.filter(i => i.category === activeTab);
          const scrollContainerRef = useRef(null);

          const handleTouchStart = (item) => {
              longPressTimerRef.current = setTimeout(() => { 
                  setIsWiggleMode(true); 
                  if (navigator.vibrate) navigator.vibrate(50); 
              }, 1000); 
          };
          const handleTouchEnd = () => { if (longPressTimerRef.current) clearTimeout(longPressTimerRef.current); };
          
          const handleTouchMove = (e, item) => {
              if (!isWiggleMode) return;
              if (e.cancelable && e.target === e.currentTarget) {
                   e.preventDefault(); 
              }
              
              const touch = e.touches[0];

              if (scrollContainerRef.current) {
                  const { top, bottom } = scrollContainerRef.current.getBoundingClientRect();
                  const touchY = touch.clientY;
                  const scrollZone = 50; 
                  const scrollSpeed = 15;

                  if (touchY < top + scrollZone) {
                      scrollContainerRef.current.scrollTop -= scrollSpeed;
                  } else if (touchY > bottom - scrollZone) {
                      scrollContainerRef.current.scrollTop += scrollSpeed;
                  }
              }
              
              const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
              const targetItemElement = targetElement?.closest('[data-item-id]');
              
              if (targetItemElement) {
                  const targetId = targetItemElement.getAttribute('data-item-id');
                  if (targetId && targetId !== item.id) {
                      const sourceIndex = items.findIndex(i => i.id === item.id);
                      const targetIndex = items.findIndex(i => i.id === targetId);
                      
                      if (sourceIndex > -1 && targetIndex > -1) {
                          const newItems = [...items];
                          const [movedItem] = newItems.splice(sourceIndex, 1);
                          newItems.splice(targetIndex, 0, movedItem);
                          reorderItems(newItems);
                      }
                  }
              }
          };

          const [editImageSrc, setEditImageSrc] = useState(null);
          const [editCategory, setEditCategory] = useState('tops');
          const [isProcessingEdit, setIsProcessingEdit] = useState(false);

          const handleItemClick = (e, item) => {
              e.stopPropagation();
              if (isWiggleMode) return; 
              setEditingItem(item);
              setEditImageSrc(item.image);
              setEditCategory(item.category);
          };

          const handleAiReprocess = async () => {
              if (!editImageSrc) return;
              setIsProcessingEdit(true);
              
              const stylePrompt = `
                Analyze this fashion item image.
                Provide a score from 0 (Casual) to 100 (Dress).
                
                Evaluation criteria:
                1. Material: Rough/Matte -> Lower. Smooth/Glossy/Wool/Silk -> Higher.
                2. Color/Pattern: Vivid/Pattern -> Lower. Monotone/Dark/Simple -> Higher.
                3. Shape: T-shirt/Shorts -> Lower. Collared/Slacks -> Higher.
                
                Analyze these 3 factors SEPARATELY.
                Return JSON: { 
                    "score": number (0-100), 
                    "materialScore": number (0-100),
                    "colorScore": number (0-100),
                    "shapeScore": number (0-100),
                    "material": "Brief description of material in Japanese", 
                    "color": "Brief description of color in Japanese", 
                    "shape": "Brief description of shape in Japanese" 
                }
              `;
              const styleResult = await callGeminiText(stylePrompt, [editImageSrc]);
              
              const categoryLabel = CATEGORIES.find(c => c.id === editCategory)?.label || 'clothing item';
              const prompt = `Crop and isolate the ${categoryLabel} from this image on a pure white background. Do not fold. Show the entire item flat and straight. High quality product photo.`;
              const processed = await callGeminiImageGen(prompt, [editImageSrc]);
              
              if (processed) {
                  const compressed = await compressImage(processed, 800, 0.8);
                  setEditImageSrc(compressed);
                  if (editingItem && styleResult) {
                      const updatedItem = {
                          ...editingItem,
                          styleType: styleResult.score >= 50 ? 'clean' : 'casual',
                          styleScore: styleResult.score,
                          styleAnalysis: {
                              material: styleResult.material,
                              materialScore: styleResult.materialScore ?? styleResult.score,
                              color: styleResult.color,
                              colorScore: styleResult.colorScore ?? styleResult.score,
                              shape: styleResult.shape,
                              shapeScore: styleResult.shapeScore ?? styleResult.score
                          }
                      };

                      updateItem(updatedItem);
                      setEditingItem(updatedItem);
                  }
              } else {
                  alert("AI加工に失敗しました");
              }
              setIsProcessingEdit(false);
          };

          const handleUpdate = () => {
              if (editingItem && editImageSrc) {
                  updateItem({ ...editingItem, image: editImageSrc, category: editCategory });
                  setEditingItem(null);
              }
          };

          const relatedFavorites = favorites.filter(fav => editingItem && fav.items.some(i => i.id === editingItem.id));

          return (
            <div className="flex flex-col h-full animate-fade-in relative" onClick={() => setIsWiggleMode(false)}>
               {isWiggleMode && <div className="px-6 pt-2 text-center"><p className="text-xs text-purple-600 animate-pulse font-bold">並べ替えモード中（ドラッグで移動）</p></div>}
              
              <div className="flex overflow-x-auto px-6 py-4 gap-2 no-scrollbar">
                <button onClick={(e) => { e.stopPropagation(); setActiveTab('all'); }} className={`whitespace-nowrap px-4 py-2 rounded-full text-sm font-bold transition shrink-0 flex items-center gap-2 ${activeTab === 'all' ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-500'}`}>
                    <LayoutGrid size={14} /> ALL
                </button>
                {CATEGORIES.map(cat => (
                    <button key={cat.id} onClick={(e) => { e.stopPropagation(); setActiveTab(cat.id); }} className={`whitespace-nowrap px-4 py-2 rounded-full text-sm font-bold transition shrink-0 flex items-center gap-2 ${activeTab === cat.id ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-500'}`}>
                      {activeTab === cat.id && <cat.icon size={14} />} {cat.label}
                    </button>
                ))}
              </div>

              <div ref={scrollContainerRef} className="flex-1 overflow-y-auto px-4 pb-24">
                {filteredItems.length === 0 ? (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <Shirt size={48} className="mb-2 opacity-20" />
                    <p>アイテムがまだありません</p>
                  </div>
                ) : (
                  <div className="grid grid-cols-3 gap-2">
                    {filteredItems.map((item) => (
                      <div 
                        key={item.id} 
                        data-item-id={item.id}
                        onClick={(e) => handleItemClick(e, item)}
                        onTouchStart={() => handleTouchStart(item)}
                        onTouchEnd={handleTouchEnd}
                        onTouchMove={(e) => handleTouchMove(e, item)}
                        style={isWiggleMode ? { touchAction: 'none' } : {}}
                        className={`relative bg-white rounded-xl overflow-hidden shadow-sm border border-gray-200 aspect-[3/4] cursor-pointer flex flex-col group transition-all duration-300 select-none ${isWiggleMode ? 'animate-wiggle ring-2 ring-purple-300 ring-offset-2 z-10' : 'hover:shadow-md'}`}>
                        <img src={item.image} alt="Clothing" className="w-full h-full object-cover pointer-events-none select-none" style={{ WebkitTouchCallout: 'none' }} /> 
                        
                        <button 
                          onClick={(e) => { e.stopPropagation(); togglePin(item.id); }}
                          className={`absolute top-1 left-1 p-1.5 rounded-full z-20 ${item.isPinned ? 'bg-yellow-400 text-white' : 'bg-white/80 text-gray-300 hover:text-yellow-400'}`}
                        >
                            <Star size={12} fill={item.isPinned ? "currentColor" : "none"} />
                        </button>
                        
                        {!isWiggleMode && <div className="absolute inset-0 bg-black/10 opacity-0 group-hover:opacity-100 transition flex items-center justify-center"><span className="bg-white/90 text-[10px] px-2 py-1 rounded-full font-bold">編集</span></div>}
                        <button onClick={(e) => { e.stopPropagation(); requestDelete(item.id); }} className="absolute top-1 right-1 bg-white/90 text-gray-400 hover:text-red-500 p-1.5 rounded-full shadow-sm border border-gray-100 z-10"><Trash2 size={12} /></button>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              {editingItem && (
                  <div className="absolute inset-0 z-40 bg-white flex flex-col animate-fade-in" onClick={(e) => e.stopPropagation()}>
                      <div className="px-6 pt-6 pb-2 flex justify-between items-center bg-white shrink-0">
                          <h2 className="text-xl font-bold text-gray-800">アイテム詳細・編集</h2>
                          <button onClick={() => setEditingItem(null)} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X size={24} /></button>
                      </div>
                      <div className="flex-1 overflow-y-auto p-6 space-y-6 pb-24">
                          <div className="relative w-full aspect-[3/4] bg-gray-100 rounded-2xl overflow-hidden shadow-md">
                              {isProcessingEdit && <div className="absolute inset-0 flex items-center justify-center bg-white/80 z-20"><MagicLoader size={32} text="AI 加工中..." /></div>}
                              <img src={editImageSrc || ''} className="w-full h-full object-contain bg-white" alt="edit" />
                              
                              <button onClick={handleAiReprocess} disabled={isProcessingEdit} className="absolute bottom-4 right-4 bg-gradient-to-r from-pink-500 to-orange-500 text-white px-3 py-2 rounded-full shadow-md text-xs font-bold flex items-center gap-1 hover:opacity-90 z-20"><Wand2 size={14} /> AI加工（切り出し）</button>
                          </div>

                          {editingItem.styleScore !== undefined && (
                                <div className="bg-white p-4 rounded-xl border border-gray-100 shadow-sm space-y-2">
                                     <h4 className="font-bold text-gray-700 text-xs flex items-center gap-1"><Info size={14} className="text-blue-500"/> スタイル分析レポート</h4>
                                     <StyleBar score={editingItem.styleScore} label="総合スタイル" />
                                     
                                     {editingItem.styleAnalysis && (
                                         <div className="grid grid-cols-1 gap-3 mt-3">
                                             <div className="bg-gray-50 p-2 rounded-lg text-[10px]">
                                                 <StyleBar score={editingItem.styleAnalysis.materialScore} label="素材感" small />
                                                 <p className="text-gray-500 mt-1">{String(editingItem.styleAnalysis.material)}</p>
                                             </div>
                                             <div className="bg-gray-50 p-2 rounded-lg text-[10px]">
                                                  <StyleBar score={editingItem.styleAnalysis.colorScore} label="色・柄" small />
                                                  <p className="text-gray-500 mt-1">{String(editingItem.styleAnalysis.color)}</p>
                                             </div>
                                             <div className="bg-gray-50 p-2 rounded-lg text-[10px]">
                                                  <StyleBar score={editingItem.styleAnalysis.shapeScore} label="形状・シルエット" small />
                                                  <p className="text-gray-500 mt-1">{String(editingItem.styleAnalysis.shape)}</p>
                                             </div>
                                         </div>
                                     )}
                                </div>
                          )}

                          <div>
                              <h4 className="font-bold text-gray-700 mb-2 text-sm">カテゴリーを変更</h4>
                              <div className="grid grid-cols-3 gap-2">
                                  {CATEGORIES.map(cat => (
                                      <button key={cat.id} onClick={() => setEditCategory(cat.id)} className={`p-2 rounded-lg text-xs font-bold flex flex-col items-center gap-1 ${editCategory === cat.id ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-600'}`}>
                                          <cat.icon size={16} />{cat.label}
                                      </button>
                                  ))}
                              </div>
                          </div>
                          <button onClick={handleUpdate} className="w-full py-3 bg-gray-900 text-white rounded-xl font-bold shadow-lg hover:bg-gray-800 flex items-center justify-center gap-2"><Check size={20} /> 変更を保存</button>
                          {relatedFavorites.length > 0 && (
                              <div className="pt-4 border-t border-gray-100">
                                  <h4 className="font-bold text-gray-700 mb-3 text-sm flex items-center gap-1"><Heart size={14} className="text-pink-500" /> このアイテムを使ったお気に入りコーデ</h4>
                                  <div className="space-y-3">
                                      {relatedFavorites.map((fav) => (
                                          <div key={fav.id} onClick={() => onSelectFavorite(fav)} className="bg-gray-50 p-2 rounded-lg flex gap-3 items-center border border-gray-100 cursor-pointer hover:bg-purple-50 transition">
                                              <div className="w-12 h-16 bg-white rounded overflow-hidden shrink-0">
                                                  {fav.generatedImage && <img src={fav.generatedImage} className="w-full h-full object-cover" alt="outfit" />}
                                              </div>
                                              <div className="overflow-hidden">
                                                  <p className="text-xs font-bold text-gray-700 truncate">{fav.season} / {fav.scene}</p>
                                                  <p className="text-[10px] text-gray-500 truncate">{fav.advice?.comment}</p>
                                                  <span className="text-[10px] text-yellow-500">★{fav.advice?.rating}</span>
                                              </div>
                                              <ChevronRight size={16} className="text-gray-400 ml-auto" />
                                          </div>
                                      ))}
                                  </div>
                              </div>
                          )}
                      </div>
                  </div>
              )}
            </div>
          );
        };

        // 4. Fitting Room View
        const FittingRoomView = ({ items, showNotification, setView, userModel, outfitState, setOutfitState, addFavorite }) => {
          const [isSelecting, setIsSelecting] = useState(false);
          const [isDiagnosing, setIsDiagnosing] = useState(false);
          const [selectingCategory, setSelectingCategory] = useState(null);
          const [lockedItems, setLockedItems] = useState({ outer: false, tops: false, bottoms: false, shoes: false, bag: false, accessories: false });
          const [showAiConfig, setShowAiConfig] = useState(false);
          const [aiConfig, setAiConfig] = useState({ season: '春', scene: 'オフィス' });
          const [actionType, setActionType] = useState('auto');

          const getSelected = (cat) => outfitState.selectedItems[cat];

          const getSortedItemsForSelection = (catId) => {
              const targetItems = items.filter(i => i.category === catId);
              const cleanItems = targetItems.filter(i => i.styleScore !== undefined && i.styleScore >= 50);
              const casualItems = targetItems.filter(i => i.styleScore === undefined || i.styleScore < 50);
              
              const sorted = [];
              const maxLength = Math.max(cleanItems.length, casualItems.length);
              
              for (let i = 0; i < maxLength; i++) {
                  if (i < casualItems.length) sorted.push(casualItems[i]);
                  if (i < cleanItems.length) sorted.push(cleanItems[i]);
              }
              return sorted;
          };

          const selectItem = (cat, item) => {
              if (cat === 'accessories' && item) {
                  const currentAcc = outfitState.selectedAccessories || [];
                  const exists = currentAcc.find(i => i.id === item.id);
                  let newAcc;
                  if (exists) {
                      newAcc = currentAcc.filter(i => i.id !== item.id);
                  } else {
                      if (currentAcc.length >= 4) {
                          showNotification("アクセサリーは最大4つまで選択できます");
                          return;
                      }
                      newAcc = [...currentAcc, item];
                  }
                  setOutfitState(prev => ({ ...prev, selectedAccessories: newAcc, generatedOutfitImage: null, aiAdvice: null, isFavorited: false }));
              } else {
                  setOutfitState(prev => ({
                      ...prev, selectedItems: { ...prev.selectedItems, [cat]: item }, generatedOutfitImage: null, aiAdvice: null, isFavorited: false 
                  }));
                  setSelectingCategory(null);
              }
          };

          const handleAiAutoCoordinate = async () => {
              if (items.length === 0) { showNotification("服が登録されていません"); return; }
              setIsSelecting(true);
              try {
                  const candidates = [];
                  const candidateImages = [];
                  const candidateIds = [];

                  CATEGORIES.forEach(cat => {
                      const hasAccessories = outfitState.selectedAccessories && outfitState.selectedAccessories.length > 0;
                      if (lockedItems[cat.id] && (cat.id === 'accessories' ? hasAccessories : getSelected(cat.id))) return;

                      const catItems = items.filter(i => i.category === cat.id);
                      const shuffled = [...catItems].sort(() => 0.5 - Math.random()).slice(0, 3);
                      shuffled.forEach(item => {
                          candidates.push({ item, category: cat.id });
                          candidateImages.push(item.image);
                          candidateIds.push(item.id);
                      });
                  });

                  if (candidateImages.length === 0) { showNotification("選択可能な候補がありません"); setIsSelecting(false); return; }
                  const seasonRule = aiConfig.season === '夏' ? 'IMPORTANT: Summer. Do NOT select "outer". Set outer to null.' : '';
                  const selectionPrompt = `
                  Stylist task. 
                  You MUST select exactly ONE item ID for "tops".
                  You MUST select exactly ONE item ID for "bottoms".
                  You MUST select exactly ONE item ID for "shoes".
                  For "outer", "bag", "accessories", pick one if suitable, otherwise null.
                  
                  Context:
                  Season: ${aiConfig.season}
                  Scene: ${aiConfig.scene}
                  Style Requirement: ${SCENE_STYLE_MAP[aiConfig.scene]}

                  Goal: Select the best combination that matches the Scene and Style Requirement perfectly.
                  The outfit should be high quality and well-coordinated, aiming for a rating of 4 stars or higher.
                  Do NOT mix conflicting styles (e.g., do not pair formal shoes with sweatpants unless requested).

                  IDs: ${JSON.stringify(candidateIds)}. 
                  JSON Response: { "tops": "id", "bottoms": "id", "shoes": "id", "outer": "id" or null, "bag": "id" or null, "accessories": "id" or null }
                  `;

                  const selectionResult = await callGeminiText(selectionPrompt, candidateImages);
                  
                  if (selectionResult) {
                      const newSelection = { ...outfitState.selectedItems };
                      let newAcc = lockedItems['accessories'] ? [...(outfitState.selectedAccessories || [])] : [];

                      Object.keys(selectionResult).forEach((key) => {
                          const catId = key;
                          const validCat = CATEGORIES.find(c => c.id === catId);
                          if (!validCat) return;
                          if (lockedItems[catId]) return;

                          const id = selectionResult[key];
                          if (id) {
                              const item = items.find(i => i.id === id);
                              if (item && item.category === catId) {
                                  if (catId === 'accessories') {
                                      if (newAcc.length < 4) newAcc.push(item);
                                  }
                                  else newSelection[catId] = item;
                              }
                          } else {
                               if (catId !== 'accessories') newSelection[catId] = null;
                          }
                      });

                      const mandatoryCategories = ['tops', 'bottoms', 'shoes'];
                      mandatoryCategories.forEach(cat => {
                          if (!newSelection[cat] && !lockedItems[cat]) {
                              const available = items.filter(i => i.category === cat);
                              if(available.length > 0) newSelection[cat] = available[Math.floor(Math.random() * available.length)];
                          }
                      });
                      
                      setOutfitState(prev => ({ ...prev, selectedItems: newSelection, selectedAccessories: newAcc, aiAdvice: null, generatedOutfitImage: null, isFavorited: false }));
                      showNotification("AIがアイテムを選びました！");
                  } else {
                      showNotification("AIの応答が無効でした");
                  }
              } catch (e) { console.error(e); showNotification("AI選択エラー"); }
              finally { setIsSelecting(false); }
          };

          const handleTryOnAndDiagnose = async () => {
              const currentItems = [];
              const accs = outfitState.selectedAccessories || [];
              const accNames = accs.map(i => i.id).join(", ");
              if (accs.length > 0) currentItems.push(...accs);

              const selectedItemDescriptions = [];

              CATEGORIES.forEach(cat => {
                  if (cat.id !== 'accessories') {
                      const item = getSelected(cat.id);
                      if (item) {
                          currentItems.push(item);
                          selectedItemDescriptions.push(`${cat.label} (ID: ${item.id})`);
                      }
                  } else if (accs.length > 0) {
                      selectedItemDescriptions.push(`Accessories (${accs.length} items)`);
                  }
              });

              if (currentItems.length === 0) { showNotification("アイテムが選択されていません"); return; }
              setIsDiagnosing(true); 
              
              try {
                  const currentImages = [];
                  if (userModel && userModel.includes(',')) currentImages.push(userModel);
                  currentItems.forEach(item => { if(item && item.image && item.image.includes(',')) currentImages.push(item.image); });
                  
                  const bgDescription = `${SCENE_BACKGROUNDS[aiConfig.scene] || 'simple background'}, ${SEASON_ATMOSPHERES[aiConfig.season] || ''}`;

                  let imagePrompt = "";
                  
                  if (userModel) {
                      imagePrompt = `(IMPORTANT: Image 0 is the Face Reference). Create a NEW full-body fashion photo. Use the FACE and HAIR from Image 0, but completely REPLACE the body, outfit, and background. The person must be wearing ONLY the following items from the other images: [${selectedItemDescriptions.join(', ')}]. IGNORE the clothes and background in Image 0. Ensure all accessories like [${accNames}] are clearly visible. Background: ${bgDescription}. Infer gender PRIMARILY from Image 0 (User Face). Do NOT infer gender from bags.`;
                  } else {
                       imagePrompt = `A full-body photograph of a person wearing all the provided clothing items and accessories together. Ensure ALL items including accessories are clearly visible. Background: ${bgDescription}. Determine the gender of the model based on the clothing style (e.g. skirt/dress -> female model, mens suit -> male model). Do NOT infer gender from bags.`;
                  }
                  
                  const textPrompt = `
                  Analyze this outfit for Season: ${aiConfig.season}, Scene: ${aiConfig.scene}.
                  
                  Selected Items List: ${selectedItemDescriptions.join(', ')}.
                  
                  IMPORTANT:
                  The first image provided is just a user reference. IGNORE the clothes the user is wearing in the first image. ONLY evaluate the items in the "Selected Items List" as if the user is wearing them. Do NOT comment on the user's original clothes.
                  
                  Respond in Japanese JSON: { "rating": 5, "comment": "...", "cleanPercent": 70, "casualPercent": 30, "scenario": "${aiConfig.scene}" } Rating 1-5 integer.
                  `;

                  const [genImage, genAdvice] = await Promise.all([
                      callGeminiImageGen(imagePrompt, currentImages),
                      callGeminiText(textPrompt, currentImages)
                  ]);
                  
                  if (genImage || genAdvice) {
                      if (genAdvice && genAdvice.cleanPercent !== undefined) {
                          genAdvice.casualPercent = 100 - genAdvice.cleanPercent;
                      }
                      setOutfitState(prev => ({ ...prev, generatedOutfitImage: genImage, aiAdvice: genAdvice, isFavorited: false }));
                  } else {
                      showNotification("生成に失敗しました");
                  }
              } catch (e) { console.error(e); showNotification("生成エラー: 通信または画像を確認してください"); }
              finally { setIsDiagnosing(false); }
          };

          const handleAddToFavorites = async () => {
              if (!outfitState.generatedOutfitImage && !outfitState.aiAdvice) return;
              if (outfitState.isFavorited) return; 
              const currentItems = [];
              
              const accs = outfitState.selectedAccessories || [];
              if (accs.length > 0) currentItems.push(...accs);

              CATEGORIES.forEach(cat => {
                  if (cat.id !== 'accessories') {
                       const item = getSelected(cat.id);
                       if (item) currentItems.push(item);
                  }
              });
              let compressedGenImage = null;
              if (outfitState.generatedOutfitImage) compressedGenImage = await compressImage(outfitState.generatedOutfitImage, 800, 0.8);

              const success = await addFavorite({
                  id: generateId(), items: currentItems, generatedImage: compressedGenImage, advice: outfitState.aiAdvice, season: aiConfig.season, scene: aiConfig.scene, date: Date.now()
              });
              if (success) {
                setOutfitState(prev => ({ ...prev, isFavorited: true }));
                showNotification("お気に入りに保存しました！");
              } else {
                showNotification("保存に失敗しました。");
              }
          };

          const handleConfigSubmit = () => {
              setShowAiConfig(false);
              if (actionType === 'auto') {
                  handleAiAutoCoordinate();
              } else {
                  handleTryOnAndDiagnose();
              }
          };

          return (
            <div className="flex flex-col h-full animate-fade-in bg-gray-50 relative">
              <div className="flex-1 overflow-y-auto pb-24 pt-4">
                  <div className="flex flex-col items-center p-4 gap-4">
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 w-full">
                          {CATEGORIES.map(cat => {
                              const currentItem = getSelected(cat.id);
                              const accItems = outfitState.selectedAccessories || [];
                              const isLocked = lockedItems[cat.id];
                              const Icon = cat.icon;
                              
                              const hasItems = cat.id === 'accessories' ? accItems.length > 0 : !!currentItem;
                              const isSelected = hasItems; 

                              return (
                                  <div key={cat.id} onClick={() => setSelectingCategory(cat.id)}
                                    className={`relative aspect-square rounded-xl overflow-hidden border cursor-pointer transition active:scale-95 ${isSelected ? 'bg-white border-2 border-purple-500 ring-2 ring-purple-100' : 'bg-gray-100 border-dashed border-gray-300'}`}>
                                      {cat.id === 'accessories' && accItems.length > 0 ? (
                                          <div className={`w-full h-full grid gap-0.5 ${accItems.length === 1 ? 'grid-cols-1' : 'grid-cols-2'}`}>
                                              {accItems.slice(0, 4).map((acc) => (
                                                  <img key={acc.id} src={acc.image} className="w-full h-full object-cover" alt="acc" />
                                              ))}
                                          </div>
                                      ) : currentItem ? (
                                          <img src={currentItem.image} className="w-full h-full object-cover" alt={cat.label} />
                                      ) : (
                                          <div className="w-full h-full flex flex-col items-center justify-center text-gray-400 gap-1 hover:bg-gray-50">
                                              <Icon size={24} /> <span className="text-[10px]">{cat.label}を選択</span> <PlusCircle size={14} className="opacity-50" />
                                          </div>
                                      )}
                                      <div className="absolute top-1 left-1 bg-white/80 text-gray-600 text-[10px] px-1.5 py-0.5 rounded pointer-events-none font-bold">{cat.label}</div>
                                      {hasItems && (
                                          <button onClick={(e) => { e.stopPropagation(); setLockedItems(p => ({...p, [cat.id]: !p[cat.id]})); }} className={`absolute top-1 right-1 p-1.5 rounded-full ${isLocked ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-500'}`}>
                                              {isLocked ? <Lock size={12} /> : <Unlock size={12} />}
                                          </button>
                                      )}
                                  </div>
                              );
                          })}
                      </div>
                      
                      <div className="w-full max-w-sm mt-2 space-y-2">
                            <button onClick={() => { setActionType('auto'); setShowAiConfig(true); }} disabled={isSelecting || isDiagnosing} className="w-full py-3 bg-gradient-to-r from-pink-500 to-orange-500 text-white rounded-xl font-bold shadow-md hover:opacity-90 flex items-center justify-center gap-2 disabled:opacity-50">
                              {isSelecting ? <MagicLoader size={20} text="" /> : <Sparkles size={20} />} {isSelecting ? "AIおまかせコーデで、洋服を選ぶ" : "AIおまかせコーデで、洋服を選ぶ"}
                            </button>
                            <button onClick={() => { setActionType('diagnose'); setShowAiConfig(true); }} disabled={isSelecting || isDiagnosing} className="w-full py-3 bg-gradient-to-r from-pink-500 to-orange-500 text-white rounded-xl font-bold shadow-md hover:shadow-lg flex items-center justify-center gap-2 disabled:opacity-50">
                                <User size={20} />
                                <span>試着＆診断する</span>
                            </button>
                      </div>

                      {(outfitState.generatedOutfitImage || outfitState.aiAdvice) && (
                          <div className="w-full max-w-sm bg-white rounded-xl shadow-xl overflow-hidden animate-slide-up border border-gray-100 mb-20">
                              {outfitState.generatedOutfitImage && (
                                  <div className="relative w-full aspect-[3/4] bg-gray-100">
                                     <img src={outfitState.generatedOutfitImage} alt="Try-on" className="w-full h-full object-cover" />
                                     <div className="absolute top-3 left-3 bg-black/60 text-white text-xs px-2 py-1 rounded-full flex items-center gap-1"><User size={12} /> 試着イメージ</div>
                                     <button onClick={handleAddToFavorites} disabled={outfitState.isFavorited} className={`absolute top-3 right-3 p-2 rounded-full shadow-sm transition transform hover:scale-110 ${outfitState.isFavorited ? 'bg-pink-500 text-white' : 'bg-white/80 text-gray-400 hover:text-pink-500'}`}>
                                         <Heart size={20} fill={outfitState.isFavorited ? "currentColor" : "none"} />
                                     </button>
                                  </div>
                              )}
                              
                              {outfitState.aiAdvice && (
                                  <div className="p-5 border-t border-gray-100">
                                      <div className="flex items-center justify-between mb-3">
                                          <h3 className="font-bold text-gray-800 flex items-center gap-2"><MessageCircle size={18} className="text-purple-600" /> AIスタイリスト</h3>
                                          <StarRating rating={outfitState.aiAdvice.rating} />
                                      </div>
                                      
                                      {outfitState.aiAdvice.cleanPercent !== undefined && outfitState.aiAdvice.casualPercent !== undefined && (
                                        <div className="mb-3 p-3 bg-gray-50 rounded-xl">
                                            <div className="w-full">
                                                <StyleBar score={outfitState.aiAdvice.cleanPercent} />
                                            </div>
                                        </div>
                                      )}

                                      <p className="text-gray-600 text-sm mb-3 leading-relaxed">{outfitState.aiAdvice.comment}</p>
                                      <div className="bg-purple-50 px-3 py-2 rounded-lg text-xs text-purple-800 font-medium inline-block">シーン: {outfitState.aiAdvice.scenario} {aiConfig.season ? `(${aiConfig.season})` : ''}</div>
                                      {!outfitState.generatedOutfitImage && (
                                           <button onClick={handleAddToFavorites} disabled={outfitState.isFavorited} className={`w-full mt-4 py-2 border rounded-lg text-sm font-bold flex items-center justify-center gap-2 transition ${outfitState.isFavorited ? 'bg-pink-50 text-pink-500 border-pink-200' : 'border-gray-200 text-gray-500 hover:bg-pink-50 hover:text-pink-500'}`}>
                                                   <Heart size={16} fill={outfitState.isFavorited ? "currentColor" : "none"} /> {outfitState.isFavorited ? "保存済み" : "お気に入りに保存"}
                                           </button>
                                      )}
                                  </div>
                              )}
                          </div>
                      )}
                  </div>
              </div>

              {(isDiagnosing || isSelecting) && (
                  <div className="absolute inset-0 z-50 bg-white/80 flex flex-col items-center justify-center animate-fade-in backdrop-blur-sm">
                      <MagicLoader size={120} text={isSelecting ? "AIがアイテムを選定中..." : "AIが試着＆診断中..."} />
                  </div>
              )}

              {selectingCategory && (
                  <div className="absolute inset-0 z-50 bg-black/50 flex items-end sm:items-center justify-center p-4 animate-fade-in" onClick={() => setSelectingCategory(null)}>
                      <div className="bg-white w-full max-w-sm rounded-t-2xl sm:rounded-2xl p-4 shadow-2xl h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                          <div className="flex justify-between items-center mb-4 shrink-0">
                              <h3 className="font-bold text-lg flex items-center gap-2">{CATEGORIES.find(c => c.id === selectingCategory)?.label}を選択</h3>
                              <button onClick={() => setSelectingCategory(null)} className="p-1 bg-gray-100 rounded-full"><X size={20}/></button>
                          </div>
                          
                          <div className="flex-1 overflow-y-auto grid grid-cols-2 gap-3 pb-4 content-start p-1">
                              {getSortedItemsForSelection(selectingCategory).map((item) => {
                                  const isSelected = selectingCategory === 'accessories' 
                                    ? outfitState.selectedAccessories?.some(i => i.id === item.id)
                                    : outfitState.selectedItems[selectingCategory]?.id === item.id;
                                  return (
                                    <div key={item.id} onClick={() => selectItem(selectingCategory, item)} 
                                        className={`relative aspect-[3/4] rounded-lg overflow-hidden border cursor-pointer ${isSelected ? 'ring-4 ring-purple-500 border-purple-500' : 'border-gray-100 hover:ring-2 ring-purple-500'}`}>
                                        <img src={item.image} className="w-full h-full object-cover" alt="item" />
                                        {isSelected && <div className="absolute top-2 right-2 bg-purple-600 text-white rounded-full p-1"><Check size={12} /></div>}
                                        {item.styleType && (
                                            <div className={`absolute bottom-1 left-1 px-1.5 py-0.5 rounded-full text-[8px] font-bold text-white opacity-90 ${item.styleType === 'clean' ? 'bg-gray-900' : 'bg-orange-500'}`}>
                                                {item.styleType === 'clean' ? 'Dress' : 'Casual'}
                                            </div>
                                        )}
                                    </div>
                                  );
                              })}
                              {items.filter(i => i.category === selectingCategory).length === 0 && <div className="col-span-2 text-center text-gray-500 py-10"><p>アイテムがまだありません</p></div>}
                          </div>
                          
                          <div className="p-4 border-t border-gray-100 bg-white">
                              {selectingCategory === 'accessories' ? (
                                  <button onClick={() => setSelectingCategory(null)} className="w-full py-3 bg-purple-600 text-white font-bold rounded-xl shadow-md">完了</button>
                              ) : (
                                  <button onClick={() => selectItem(selectingCategory, null)} className="w-full py-3 border-2 border-gray-200 text-gray-500 font-bold rounded-xl hover:bg-gray-50">選択を解除</button>
                              )}
                          </div>
                      </div>
                  </div>
              )}

              {showAiConfig && (
                  <div className="absolute inset-0 z-50 bg-black/50 flex items-center justify-center p-4 animate-fade-in" onClick={() => setShowAiConfig(false)}>
                      <div className="bg-white w-full max-w-xs rounded-2xl p-6 shadow-2xl space-y-4" onClick={e => e.stopPropagation()}>
                          <h3 className="font-bold text-lg flex items-center gap-2"><Sparkles className="text-purple-500" size={20} /> コーデの条件を設定</h3>
                          <div>
                              <label className="text-xs font-bold text-gray-500 mb-1 block">季節</label>
                              <div className="grid grid-cols-4 gap-2">
                                  {SEASONS.map(s => <button key={s} onClick={() => setAiConfig({...aiConfig, season: s})} className={`py-2 rounded-lg text-xs font-bold transition ${aiConfig.season === s ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-600'}`}>{s}</button>)}
                              </div>
                          </div>
                          
                          <div>
                              <label className="text-xs font-bold text-gray-500 mb-1 block">シチュエーション（きれいめ）</label>
                              <div className="grid grid-cols-2 gap-2 mb-2">
                                  {SCENES_FORMAL.map(s => <button key={s} onClick={() => setAiConfig({...aiConfig, scene: s})} className={`py-2 px-2 rounded-lg text-xs font-bold transition text-left ${aiConfig.scene === s ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-600'}`}>{s}</button>)}
                              </div>
                          </div>

                          <div>
                              <label className="text-xs font-bold text-gray-500 mb-1 block">シチュエーション（カジュアル）</label>
                              <div className="grid grid-cols-2 gap-2">
                                  {SCENES_CASUAL.map(s => <button key={s} onClick={() => setAiConfig({...aiConfig, scene: s})} className={`py-2 px-2 rounded-lg text-xs font-bold transition text-left ${aiConfig.scene === s ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-600'}`}>{s}</button>)}
                              </div>
                          </div>

                          <button onClick={handleConfigSubmit} className="w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-xl font-bold shadow-md mt-4">{actionType === 'auto' ? 'アイテムを自動選択' : '試着＆診断を開始'}</button>
                      </div>
                  </div>
              )}
            </div>
          );
        };

        // 5. Coordinate View
        const CoordinateView = ({ showNotification, setView, favorites, deleteFavorite, setSelectedFavorite }) => {
            const [filterSeason, setFilterSeason] = useState('all');
            const [filterScene, setFilterScene] = useState('all');
            const [isFilterOpen, setIsFilterOpen] = useState(false);

            const filteredFavorites = favorites.filter((fav) => {
                const matchSeason = filterSeason === 'all' || fav.season === filterSeason;
                const matchScene = filterScene === 'all' || fav.scene === filterScene;
                return matchSeason && matchScene;
            });

            return (
                <div className="flex flex-col h-full animate-fade-in bg-white">
                    <div className="px-6 pt-6 pb-2 flex justify-between items-center">
                        <h2 className="text-2xl font-bold text-gray-800">Coordinate Book</h2>
                        <button onClick={() => setIsFilterOpen(!isFilterOpen)} className={`flex items-center gap-1 px-3 py-2 rounded-full text-xs font-bold transition border ${isFilterOpen ? 'bg-purple-600 text-white border-purple-600' : 'bg-white text-gray-500 border-gray-200'}`}>
                            <ListFilter size={14} /> 絞り込み
                        </button>
                    </div>
                    {isFilterOpen && (
                        <div className="px-6 py-3 bg-gray-50 border-b border-gray-100 animate-slide-up">
                            <div className="flex gap-2 mb-2">
                                <select value={filterSeason} onChange={(e) => setFilterSeason(e.target.value)} className="text-xs p-2 rounded-lg border border-gray-200 bg-white flex-1">
                                    <option value="all">季節：すべて</option>
                                    {SEASONS.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                                <select value={filterScene} onChange={(e) => setFilterScene(e.target.value)} className="text-xs p-2 rounded-lg border border-gray-200 bg-white flex-1">
                                    <option value="all">シーン：すべて</option>
                                    {SCENES.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                            </div>
                            <div className="flex justify-between items-center">
                                <p className="text-[10px] text-gray-400">{filteredFavorites.length}件見つかりました</p>
                                {(filterSeason !== 'all' || filterScene !== 'all') && <button onClick={() => { setFilterSeason('all'); setFilterScene('all'); }} className="text-[10px] text-purple-500 underline">リセット</button>}
                            </div>
                        </div>
                    )}
                    <div className="flex-1 overflow-y-auto p-6 space-y-8 pb-24">
                        {filteredFavorites.length === 0 ? (
                            <div className="text-center text-gray-400 py-12 bg-gray-50 rounded-xl border-dashed border-2 border-gray-200">
                                <p className="text-sm font-medium">お気に入りがありません</p>
                                <p className="text-xs mt-2 text-gray-500 flex items-center justify-center gap-1 flex-wrap">
                                    Fittingで「試着＆診断」を行い、<br/>
                                    お気に入り <Heart size={12} className="inline text-pink-500 fill-pink-500" /> 登録しましょう
                                </p>
                            </div>
                        ) : (
                            <div className="space-y-6">
                                {filteredFavorites.map((fav) => {
                                    const commentText = typeof fav.advice?.comment === 'string' ? fav.advice.comment : String(fav.advice?.comment || "");
                                    
                                    return (
                                    <div key={fav.id} onClick={() => setSelectedFavorite(fav)} className="bg-white rounded-xl border border-gray-100 shadow-sm overflow-hidden cursor-pointer hover:shadow-md transition">
                                        <div className="flex">
                                            <div className="w-1/2 aspect-[3/4] bg-gray-100 relative">
                                                {fav.generatedImage ? <img src={fav.generatedImage} className="w-full h-full object-cover" alt="Gen" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Sparkles size={24} /></div>}
                                            </div>
                                            <div className="w-1/2 p-3 flex flex-col justify-between">
                                                <div>
                                                    <div className="flex items-center justify-between mb-2">{fav.advice?.rating && <StarRating rating={fav.advice.rating} />}</div>
                                                    <p className="text-xs text-gray-600 line-clamp-3 mb-2">{commentText}</p>
                                                    <div className="flex flex-wrap gap-1">
                                                        {fav.season && <span className="inline-block bg-blue-50 text-blue-700 text-[10px] px-2 py-0.5 rounded">{fav.season}</span>}
                                                        {fav.scene && <span className="inline-block bg-purple-50 text-purple-700 text-[10px] px-2 py-0.5 rounded">{fav.scene}</span>}
                                                    </div>
                                                </div>
                                                <div className="flex justify-end mt-2"><span className="text-[10px] text-gray-400">{new Date(fav.date).toLocaleDateString()}</span></div>
                                            </div>
                                        </div>
                                        <div className="bg-gray-50 px-3 py-2 flex gap-2 overflow-x-auto no-scrollbar border-t border-gray-100">
                                            {fav.items.map((item, i) => <img key={i} src={item.image} className="w-8 h-8 rounded-full border border-white shadow-sm object-cover shrink-0" alt="item" />)}
                                        </div>
                                    </div>
                                )})}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- Main App Component ---
        const App = () => {
          const [items, setItems] = useState([]);
          const [view, setView] = useState('home');
          const [notification, setNotification] = useState(null);
          const [deleteTargetId, setDeleteTargetId] = useState(null);
          const [userModel, setUserModel] = useState(null);
          const [editorState, setEditorState] = useState({ imageSrc: null, category: 'tops' });
          const [lastSelectedCategory, setLastSelectedCategory] = useState('tops');
          
          const [outfitState, setOutfitState] = useState({ 
              selectedItems: { outer: null, tops: null, bottoms: null, shoes: null, bag: null, accessories: null }, 
              selectedAccessories: [],
              aiAdvice: null, 
              generatedOutfitImage: null,
              isFavorited: false
          });
          const [favorites, setFavorites] = useState([]);
          const [selectedFavorite, setSelectedFavorite] = useState(null);
          const navFileInputRef = useRef(null);

          useEffect(() => {
            const saved = localStorage.getItem('my-closet-data');
            if (saved) { try { setItems(JSON.parse(saved)); } catch (e) {} }
            const savedUser = localStorage.getItem('my-closet-user');
            if (savedUser) setUserModel(savedUser);
            const savedFavs = localStorage.getItem('my-closet-favorites');
            if (savedFavs) { try { setFavorites(JSON.parse(savedFavs)); } catch (e) {} }
          }, []);

          useEffect(() => { try { localStorage.setItem('my-closet-data', JSON.stringify(items)); } catch (e) { setNotification("容量がいっぱいです。"); } }, [items]);
          useEffect(() => { try { if (userModel) localStorage.setItem('my-closet-user', userModel); else localStorage.removeItem('my-closet-user'); } catch (e) { setNotification("画像保存失敗(容量)"); } }, [userModel]);
          useEffect(() => { try { localStorage.setItem('my-closet-favorites', JSON.stringify(favorites)); } catch (e) { setNotification("お気に入り保存失敗(容量)"); } }, [favorites]);

          const showNotification = (msg) => { setNotification(msg); setTimeout(() => setNotification(null), 3000); };
          const addItem = (item) => setItems(prev => [item, ...prev]);
          const reorderItems = (newItems) => setItems(newItems);
          const updateItem = (updatedItem) => { setItems(prev => prev.map(item => item.id === updatedItem.id ? updatedItem : item)); showNotification("アイテムを更新しました"); };
          const confirmDelete = () => { if (deleteTargetId) { setItems(prev => prev.filter(i => i.id !== deleteTargetId)); setDeleteTargetId(null); showNotification("削除しました"); } };
          const addFavorite = async (outfit) => { setFavorites(prev => [outfit, ...prev]); return true; };
          const deleteFavorite = (id) => { setFavorites(prev => prev.filter(f => f.id !== id)); showNotification("お気に入りを削除しました"); setSelectedFavorite(null); };

          const handleSelectFavorite = (fav) => {
              setSelectedFavorite(fav);
          };

          const handleNavFileUpload = (e) => {
              const file = e.target.files?.[0];
              if (file) {
                  const reader = new FileReader();
                  reader.onload = (ev) => { setEditorState({ imageSrc: ev.target?.result, category: lastSelectedCategory }); setView('camera'); };
                  reader.readAsDataURL(file); e.target.value = ''; 
              }
          };
          
          const togglePin = (itemId) => {
              setItems(prevItems => {
                  const targetItem = prevItems.find(i => i.id === itemId);
                  if (!targetItem) return prevItems;
           
                  const isPinned = !targetItem.isPinned;
                  const updatedItem = { ...targetItem, isPinned };
                  
                  const newItems = prevItems.map(i => i.id === itemId ? updatedItem : i);
                  
                  return newItems.sort((a, b) => {
                      if (a.isPinned !== b.isPinned) {
                          return a.isPinned ? -1 : 1;
                      }
                      return b.date - a.date;
                  });
              });
              showNotification("お気に入りを変更しました");
          };

          return (
            <div className="bg-gray-100 h-screen w-full flex items-center justify-center font-sans text-gray-900">
              <div className="bg-white w-full h-full max-w-md relative shadow-2xl overflow-hidden flex flex-col">
                <div className="flex-1 overflow-hidden relative">
                  {view === 'home' && <HomeView items={items} setView={setView} userModel={userModel} setUserModel={setUserModel} showNotification={showNotification} />}
                  {view === 'camera' && <CameraEditorView addItem={addItem} setView={setView} showNotification={showNotification} editorState={editorState} setEditorState={setEditorState} setLastSelectedCategory={setLastSelectedCategory} />}
                  {view === 'closet' && <ClosetView items={items} requestDelete={setDeleteTargetId} updateItem={updateItem} favorites={favorites} onSelectFavorite={handleSelectFavorite} reorderItems={reorderItems} togglePin={togglePin} />}
                  {view === 'fitting' && <FittingRoomView items={items} showNotification={showNotification} setView={setView} userModel={userModel} outfitState={outfitState} setOutfitState={setOutfitState} addFavorite={addFavorite} />}
                  {(view === 'coordinate' || view === 'model') && <CoordinateView showNotification={showNotification} setView={setView} favorites={favorites} deleteFavorite={deleteFavorite} setSelectedFavorite={setSelectedFavorite} />}
                </div>
                
                {selectedFavorite && (
                    <FavoriteDetailOverlay 
                        favorite={selectedFavorite} 
                        onClose={() => setSelectedFavorite(null)} 
                        onDelete={deleteFavorite} 
                    />
                )}

                {deleteTargetId && (
                    <div className="absolute inset-0 z-[70] bg-black/60 flex items-center justify-center p-6 animate-fade-in">
                        <div className="bg-white rounded-2xl p-6 w-full max-w-xs shadow-2xl text-center">
                            <div className="bg-red-100 w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-red-500"><AlertTriangle size={24} /></div>
                            <h3 className="text-lg font-bold mb-2">アイテムを削除しますか？</h3>
                            <div className="flex gap-3">
                                <button onClick={() => setDeleteTargetId(null)} className="flex-1 py-3 bg-gray-100 text-gray-700 font-bold rounded-xl hover:bg-gray-200">キャンセル</button>
                                <button onClick={confirmDelete} className="flex-1 py-3 bg-red-500 text-white font-bold rounded-xl hover:bg-red-600 shadow-md">削除する</button>
                            </div>
                        </div>
                    </div>
                )}

                {notification && <div className="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gray-900 text-white px-4 py-2 rounded-full text-sm shadow-xl animate-bounce-in z-50 whitespace-nowrap flex items-center gap-2"><Check size={14} className="text-green-400" />{notification}</div>}
                <input type="file" ref={navFileInputRef} onChange={handleNavFileUpload} accept="image/*" className="hidden" />

                <div className="h-20 bg-white border-t border-gray-100 flex items-center justify-around px-2 shrink-0 z-10 pb-2">
                    <button onClick={() => setView('home')} className={`p-2 rounded-xl flex flex-col items-center gap-1 w-16 transition ${view === 'home' ? 'text-purple-600' : 'text-gray-400 hover:text-gray-600'}`}><Home size={24} /><span className="text-[10px] font-medium">Home</span></button>
                    <button onClick={() => setView('closet')} className={`p-2 rounded-xl flex flex-col items-center gap-1 w-16 transition ${view === 'closet' ? 'text-purple-600' : 'text-gray-400 hover:text-gray-600'}`}><Box size={24} /><span className="text-[10px] font-medium">Closet</span></button>
                    <div className="relative -top-5"><button onClick={() => navFileInputRef.current?.click()} className="bg-gray-900 text-white p-4 rounded-full shadow-lg shadow-purple-200 hover:scale-105 transition transform active:scale-95"><PlusCircle size={28} /></button></div>
                    <button onClick={() => setView('fitting')} className={`p-2 rounded-xl flex flex-col items-center gap-1 w-16 transition ${view === 'fitting' ? 'text-purple-600' : 'text-gray-400 hover:text-gray-600'}`}><Shirt size={24} /><span className="text-[10px] font-medium">Fitting</span></button>
                    <button onClick={() => setView('coordinate')} className={`p-2 rounded-xl flex flex-col items-center gap-1 w-16 transition ${view === 'coordinate' || view === 'model' ? 'text-purple-600' : 'text-gray-400 hover:text-gray-600'}`}><User size={24} /><span className="text-[10px] font-medium">Coordinate</span></button>
                </div>
              </div>
            </div>
          );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
